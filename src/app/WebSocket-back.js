var sockjs = require('sockjs');var WebSocketClient = require('./WebSocketClient');var WebSocketClientContainer = WebSocketClient.WebSocketClientContainer;var url = require('url');var querystring  = require('querystring');var http = require('http');var wsConns = require('./wsConns');/** * A decorator for Sockjs * @param httpServer * @param app Application * @constructor */function WebSocket(httpServer, app){    var implementation = sockjs.createServer({ sockjs_url: 'http://cdn.jsdelivr.net/sockjs/1.0.1/sockjs.min.js' });    mixin(this, implementation);    this.socketsKey = {};    this.socketsObj = {};    this.rooms = {};    if(!httpServer){        httpServer = http.createServer(app.callback());    }    this.server = httpServer;    this.installHandlers(httpServer, {prefix:'/echo'});    this.installHandlers(httpServer, {prefix:'/bot'});    this.on('connection', this.onIncomeConnect.bind(this));}/** * Emits an event to all connected clients. * @param sockets ?=Object<Array | WebSocketClient> * @param data */WebSocket.prototype.broadcast = function(sockets, data){    var input = sockets ? sockets : this.socketsKey;    if(Array.isArray(input)){        input.forEach(function(socket){            socket.emit(data);        })    }};/** * Gets a list of client IDs connected to this namespace * @return Array<Client> */WebSocket.prototype.getClients = function(){    if(!this.rooms['/']){        return null;    }    return this.rooms['/'].map(function(socket){        return socket.client;    });};/** * incoming connect listener * @param conn */WebSocket.prototype.onIncomeConnect = function(conn){    var me = this;    //wait for remove********************    if(conn.prefix==='/echo'){        var id = getId(conn);        wsConns[id] = conn;        conn.on('close', function() {            var id = getId(this);            delete wsConns[id];            console.error('connection closed');        });        function getId(conn){            var query = url.parse(conn.url).query;            return querystring.parse(query).id;        }        return;    }    //************************************    var query = url.parse(conn.url).query;    if(!query){        return;    }    id = querystring.parse(query).id;    var socket = new WebSocketClient(id, conn, this);    !this.socketsKey[conn.prefix] && (this.socketsKey[conn.prefix] = []);    socket._id = id;    this.socketsObj[id] = socket;    this.socketsKey[conn.prefix].push(id);    conn.on('data', me.onIncomeMessage.bind(me));    conn.on('close', this.onClose(me));};/** * Close connect listener * @param websocket WebSocket */WebSocket.prototype.onClose = function(websocket){    var ws = websocket;    return function(){        var conn = this;        var query = url.parse(conn.url).query;        if(!query){            return;        }        id = querystring.parse(query).id;        ws.socketsObj[id].leave();        if(ws.socketsKey[conn.prefix].length){            ws.socketsKey[conn.prefix].forEach(function(key, index){                if(key === id){                    ws.socketsKey[conn.prefix].splice(index, 1);                }            })        }        delete ws.socketsObj[id];    }};/** * external interface used for listening messages * @param callback */WebSocket.prototype.onMessage = function(callback){    this.on('on_message', callback);};/** * incoming message listener * @param data */WebSocket.prototype.onIncomeMessage = function(data){    var msg = null;    var me = this;    try{        msg = JSON.parse(data);        var socketId = msg.socketId;        var prefix = msg.prefix;        if (msg.data.method === 'subscribe') {            this.socketsKey[prefix].forEach(function(key){                if(!key){                    return;                }                if(key === socketId){                    socket = me.socketsObj[key];                    socket.join(msg.data.channel);                }            })        }        this.emit('on_message', msg);    }catch(e){        console.error(e);    }};/** * Initializes and retrieves the given Namespace by its pathname identifier nsp. * @param urlStr string; */WebSocket.prototype.of = function(urlStr){    var me = this;    var sid = null;    var urlJson = url.parse(urlStr);    var pathname = urlJson.pathname;    if(urlJson.query){        var query = querystring.parse(urlJson.query);        if(query && query.id){            sid = query.id;        }    }    if(!this.rooms[pathname]){        return new WebSocketClientContainer();    }    var sockets = this.rooms[pathname].map(function(socket){        if(sid && sid === socket){            return sid;        }else{            return me.socketsObj[socket];        }    });    return new WebSocketClientContainer(pathname, sockets);};module.exports = function(httpServer, webFramework){    return new WebSocket(httpServer, webFramework);};function mixin(t, s){    for(var p in s){        t[p] = s[p];    }}