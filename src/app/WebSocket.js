var sockjs = require('sockjs');var WebSocketClient = require('./WebSocketClient');var WebSocketInvocation = require('./WebSocketInvocation');var WebSocketClientContainer = WebSocketClient.WebSocketClientContainer;var url = require('url');var querystring  = require('querystring');var http = require('http');var wsConns = require('./wsConns');/** * A decorator for Sockjs * @param httpServer * @param app Application * @constructor */function WebSocket(httpServer, app){    var implementation = sockjs.createServer({ sockjs_url: 'http://cdn.jsdelivr.net/sockjs/1.0.1/sockjs.min.js' });    mixin(this, implementation);    this.socketsKey = {};    this.socketsObj = {};    this.rooms = {};    if(!httpServer){        httpServer = http.createServer(app.callback());    }    this.server = httpServer;    this.installHandlers(httpServer, {prefix:'/echo'});    this.installHandlers(httpServer, {prefix:'/bot'});    this.on('connection', this.onIncomeConnect.bind(this));}/** * incoming connect listener * @param conn */WebSocket.prototype.onIncomeConnect = function(conn){    var me = this;    //wait for remove********************    if(conn.prefix==='/echo'){        var id = getId(conn);        wsConns[id] = conn;        conn.on('close', function() {            var id = getId(this);            delete wsConns[id];            console.error('connection closed');        });        function getId(conn){            var query = url.parse(conn.url).query;            return querystring.parse(query).id;        }        return;    }    //************************************    var query = url.parse(conn.url).query;    if(!query){        return;    }    id = conn.id;    var socket = new WebSocketClient(id, conn, this);    var r = querystring.parse(query).r;    if(r){        socket.join(r);    }    !this.socketsKey[conn.prefix] && (this.socketsKey[conn.prefix] = []);    this.socketsObj[id] = socket;    this.socketsKey[conn.prefix].push(id);    conn.on('data', me.onIncomeMessage.bind(me));    conn.on('close', this.onClose(me));};/** * Close connect listener * @param websocket WebSocket */WebSocket.prototype.onClose = function(websocket){    var ws = websocket;    return function(){        var conn = this;        var id = conn.id;        ws.socketsObj[id].leave();        if(ws.socketsKey[conn.prefix].length){            ws.socketsKey[conn.prefix].forEach(function(key, index){                if(key === id){                    ws.socketsKey[conn.prefix].splice(index, 1);                }            })        }        delete ws.socketsObj[id];    }};/** * external interface used for listening messages * @param callback */WebSocket.prototype.onMessage = function(callback){    this.on('on_message', callback);};/** * incoming message listener * @param data */WebSocket.prototype.onIncomeMessage = function(data){    var msg = null;    try{        msg = JSON.parse(data);        this.emit('on_message', msg);    }catch(e){        console.error(e);    }};/** * Initializes and retrieves the given Namespace by its pathname identifier nsp. * @param urlStr string; */WebSocket.prototype.of = function(urlStr){    var me = this;    var invocation = new WebSocketInvocation(me);    invocation.setChannel(urlStr);    return invocation;};/** * Obtain all connection by given room identifier * @param room */WebSocket.prototype.in = function(room){    var me = this;    var conns = this.rooms[room];    var invocation = new WebSocketInvocation(me);    invocation.setConns(conns);    return invocation;};/** * Obtain clients * @param invocation Invocation */WebSocket.prototype.clients = function(invocation){    var me = this;    var sockets = null;    if(invocation){        sockets = invocation.conns.map(function(conn){            return me.socketsObj[conn];        });    }else{        sockets = me.socketsObj.map(function(o){            return o[Object.keys(o)[0]];        })    }    var channel = invocation && invocation.channel || '/';    return new WebSocketClientContainer(channel, sockets);};module.exports = function(httpServer, webFramework){    return new WebSocket(httpServer, webFramework);};function mixin(t, s){    for(var p in s){        t[p] = s[p];    }}