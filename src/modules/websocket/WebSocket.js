var co = require('co');var sockjs = require('sockjs');var WebSocketClient = require('./WebSocketClient');var WebSocketInvocation = require('./WebSocketInvocation');var WebSocketClientContainer = WebSocketClient.WebSocketClientContainer;var url = require('url');var querystring  = require('querystring');var http = require('http');var wsConns = require('../../../src/app/wsConns');var context = require('../../../src/context').context;/** * A decorator for Sockjs * @param httpServer * @param app Application * @constructor */function WebSocket(httpServer, app){    var implementation = sockjs.createServer({ sockjs_url: 'http://cdn.jsdelivr.net/sockjs/1.0.1/sockjs.min.js' });    mixin(this, implementation);    this.socketsKey = {};    this.socketsObj = {};    this.rooms = {};    if(!httpServer){        httpServer = http.createServer(app.callback());    }    this.server = httpServer;    this.installHandlers(httpServer, {prefix:'/echo'});    this.installHandlers(httpServer, {prefix:'/bot'});    this.on('connection', this.onConnect.bind(this));}/** * incoming connect listener * @param conn */WebSocket.prototype.onConnect = function(conn){    var me = this;    me.emit('connect', conn);    co(function*(){        if(conn.prefix==='/echo'){            var id = getId(conn);            wsConns[id] = conn;            conn.on('close', function() {                var id = getId(this);                delete wsConns[id];                console.error('connection closed');            });            function getId(conn){                var query = url.parse(conn.url).query;                return querystring.parse(query).id;            }            return;        }        try{            var query = url.parse(conn.url).query;            if(!query){                return;            }            id = conn.id;            var socket = new WebSocketClient(id, conn, me);            var r = querystring.parse(query).r;            if(r){                socket.join(r);            }            if(!me.socketsKey[conn.prefix]){                me.socketsKey[conn.prefix] = []            }            me.setSocketObj(id, socket);            yield me.setSocketKey(conn.prefix, id);            conn.on('data', me.onIncomeMessage.bind(me));            conn.on('close', me.onClose(me));        }catch(e){            console.error(e)        }    });};/** * Close connect listener * @param websocket WebSocket */WebSocket.prototype.onClose = function(websocket){    var ws = websocket;    return function(){        var conn = this;        var id = conn.id;        co(function*(){            try{                ws.getSocketObj(id).leave();                var arr = yield ws.getSocketKey(conn.prefix);                if(arr.length){                    yield ws.delSocketKey(conn.prefix, id);                }                delete ws.delSocketObj(id);            }catch(e){                console.error(e);            }        })    }};/** * incoming message listener * @param data */WebSocket.prototype.onIncomeMessage = function(data){    var msg = null;    try{        msg = JSON.parse(data);        this.emit('message', msg);    }catch(e){        console.error(e);    }};/** * Initializes and retrieves the given Namespace by its pathname identifier nsp. * @param urlStr string; */WebSocket.prototype.of = function(urlStr){    var me = this;    var invocation = new WebSocketInvocation(me);    invocation.setChannel(urlStr);    return invocation;};/** * Obtain all connection by given room identifier * @param room */WebSocket.prototype.in = function(room){    var me = this;    var conns = this.rooms[room];    var invocation = new WebSocketInvocation(me);    invocation.setConns(conns);    return invocation;};WebSocket.prototype.setSocketObj = function(id, socket){    this.socketsObj[id] = socket;};WebSocket.prototype.getAllSocketObj = function(){    return this.socketsObj;};WebSocket.prototype.getSocketObj = function(id){    return this.socketsObj[id];};WebSocket.prototype.delSocketObj = function(id){    delete this.socketsObj[id];};WebSocket.prototype.getSocketKey = function* (prefix){    try{        var kvs = context.kvs.ws;        return yield kvs.getSocketKeyAsync(prefix);    }catch(e){        console.error(e);    }};WebSocket.prototype.setSocketKey = function* (prefix, key){    try{        var kvs = context.kvs.ws;        return yield kvs.addSocketKeyAsync(prefix, key);    }catch(e){        console.error(e);    }};WebSocket.prototype.delSocketKey = function* (prefix, id){    try{        var kvs = context.kvs.ws;        return yield kvs.remSocketKeyAsync(prefix, id);    }catch(e){        console.error(e);    }};/** * Obtain clients * @param invocation Invocation */WebSocket.prototype.clients = function(invocation){    var me = this;    var sockets = null;    if(invocation){        if(invocation.conns){            sockets = invocation.conns.map(function(conn){                return me.getSocketObj(conn);            });        }    }else{        sockets = me.getAllSocketObj().map(function(o){            return o[Object.keys(o)[0]];        })    }    var channel = invocation && invocation.channel || '/';    return new WebSocketClientContainer(channel, sockets);};module.exports = function(httpServer, webFramework){    return new WebSocket(httpServer, webFramework);};function mixin(t, s){    for(var p in s){        t[p] = s[p];    }}